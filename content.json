{"meta":{"title":"张广群的博客","subtitle":"个人学习笔记","description":"读书笔记 | 技术笔记","author":"张广群","url":"https://www.zhangguangqun.com","root":"/"},"pages":[{"title":"","date":"2019-04-15T13:01:55.002Z","updated":"2019-04-15T13:01:55.002Z","comments":false,"path":"categories/index.html","permalink":"https://www.zhangguangqun.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-15T13:01:55.002Z","updated":"2019-04-15T13:01:55.002Z","comments":false,"path":"tags/index.html","permalink":"https://www.zhangguangqun.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"解决 ansible shell 模块由于 $PATH 不对而找不到执行文件的问题","slug":"solution001","date":"2019-05-03T03:52:52.000Z","updated":"2019-05-09T03:52:52.000Z","comments":true,"path":"20190503/solution001/","link":"","permalink":"https://www.zhangguangqun.com/20190503/solution001/","excerpt":"","text":"问题描述今天写 ansible-playbook 脚本来部署一个 golang 的程序，服务器上已经配好了环境变量，可是任然出现找不到 go 的执行命令错误 &quot;stderr&quot;: &quot;/bin/sh: 1: go: not found&quot;，以下记录下解决这个问题的过程。 解决问题过程task 是这么写的： 1234- name: 编译代码 shell: go build args: chdir: /root/go/src/testProject 执行 ansible 会报如下错误：&quot;stderr&quot;: &quot;/bin/sh: 1: go: not found&quot; ansible 出错日志 于是手动 ssh 到那台服务器上，cd 到那个目录，执行 go build 是没问题的。开始我想是不是没配 golang 的环境变量，于是检查 /etc/profile ，是配了环境变量的，执行 go 命令也是没问题的，那是什么问题？ golang 的执行路径是 /usr/local/go/bin/go，这个是不在 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 这些 linux 常用环境变量里，将 go 软链接到 /bin 目录下，(这种方案理论上可以，后文有说明，没测试)，不过我觉得这个解决方案不优雅，因为之后如果又有其他的执行命令找不到，又需要创建软连接，因此没有去尝试这种方案。 直接写执行文件的全路径，这样可行，不过我也不想用这种方法 这样是可行的： 1234- name: 编译代码 shell: /usr/local/go/bin/go build args: chdir: /root/go/src/testProject 以下两种写法不可行： 12345- name: 编译代码 shell: go build args: chdir: /root/go/src/testProject executable: /usr/local/go/bin/go 12345- name: 编译代码 shell: build args: chdir: /root/go/src/testProject executable: /usr/local/go/bin/go 是因为配在 /etc/profile 的环境变量在执行 ansible-playbook 时不生效吗？于是我尝试把 golang 的环境变量配置 /root/.bashrc 里（因为我我配的 remote_user = root），可是这样尝试后依然不起作用。哪是什么问题？debug 一下吧， 加上 debug： 12345678910- name: debug shell: whoami- name: debug shell: echo $PATH- name: debug shell: source /root/.bashrc &amp;&amp; echo $PATH args: executable: /bin/bash debug 日志 (TIP: 执行 ansible-playbook 命令，在最后面加上 -v 可以看到详细日志，加 -vvv 可以看到更详细)： ansible debug 日志 发现直接执行 echo $PATH 和 source /root/.bashrc &amp;&amp; echo $PATH 打印的都是 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 这个路径，是一样的，这完全不科学啊，而且直接 ssh 到主机上，执行 echo $PATH 结果是 /root/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin，这跟那两个又不一样。那 ansible 的环境变量用的哪个呢？经过查找资料，得到这样的结论：ansible 使用的环境变量是配在 ansible 里的，并不和 remote_user 相关联，需要 playbooks 文件里作如下配置，配置 environment.PATH , 也就是 ansible 如果不配置这个，默认使用的 $PATH 是 ansible_env.PATH，也就是 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 这个。 123456- name: deploy hosts: all environment: PATH: \"&#123;&#123; ansible_env.PATH &#125;&#125;:/usr/local/go/bin\" roles: - deploy 解决方案 推荐: 在 playbook 像如下这样配置 environment.PATH，详细请查看 ansible 官方文档 Setting the Environment and Working With Proxies 123456- name: deploy hosts: all environment: PATH: \"&#123;&#123; ansible_env.PATH &#125;&#125;:/usr/local/go/bin\" roles: - deploy 写执行文件全路径 创建执行文件的软连接到 /bin 目录 (理论上可行，没尝试)","categories":[],"tags":[{"name":"解决方案","slug":"解决方案","permalink":"https://www.zhangguangqun.com/tags/解决方案/"},{"name":"ansible","slug":"ansible","permalink":"https://www.zhangguangqun.com/tags/ansible/"},{"name":"ansible-book","slug":"ansible-book","permalink":"https://www.zhangguangqun.com/tags/ansible-book/"}]},{"title":"swift 语言概要 - 7. 错误处理","slug":"swift07","date":"2019-04-29T13:23:42.000Z","updated":"2019-04-29T13:23:42.000Z","comments":true,"path":"20190429/swift07/","link":"","permalink":"https://www.zhangguangqun.com/20190429/swift07/","excerpt":"","text":"错误处理可以使用任何类型去采用 Error 协议来定义错误。12345enum PrinterError: Error &#123; case outOfPaper case noToner case onFire&#125; 用 throw 关键字抛出一个错误，用 throws 来标记一个方法可以抛出一个错误。如果在一个方法中抛出了错误，这个方法就会立刻返回，调用这个方法的地方需要处理这个错误。123456func send(job: Int, toPrinter printerName: String) throws -&gt; String &#123; if printerName == \"Never Has Toner\" &#123; throw PrinterError.noToner &#125; return \"Job sent\"&#125; 有几种方式来处理错误。一种方式是使用 do-catch, 在 do 的块之内，在可能抛出错误的方法前写上 try。除非给错误自定义名字，否则错误会自动命名为 error 。123456do &#123; let printerResponse = try send(job: 1040, toPrinter: \"Never Has Toner\") print(printerResponse)&#125; catch &#123; print(error) // noToner&#125; 可以使用多个 catch 块来处理特殊的错误。在 catch 写的模式和在 switch-case 的 case 是一样的。12345678910do &#123; let printerResponse = try send(job: 1440, toPrinter: \"Never Has Toner\") print(printerResponse)&#125; catch PrinterError.noToner &#123; print(\"PrinterError.noToner\") // PrinterError.noToner&#125; catch let printerError as PrinterError &#123; print(\"Printer error: \\(printerError).\")&#125; catch &#123; print(error)&#125; 另外一个处理错误的方式是用 try? 来将结果转换为可选的。如果一个函数抛了一个错误，这个特定的错误被丢弃了，函数的结果是 nil，否者，结果是这个方法返回的可选值类型的值。1234let printerSuccess = try? send(job: 1884, toPrinter: \"Mergenthaler\")let printerFailure = try? send(job: 1885, toPrinter: \"Never Has Toner\")print(printerSuccess)print(printerFailure) 在 defer 关键字后写一个代码块，该代码块在函数返回之前且在函数中的所有其他代码之后执行。 无论函数是否抛出错误，都会执行代码。1234567891011121314var fridgeIsOpen = falselet fridgeContent = [\"milk\", \"eggs\", \"leftovers\"]func fridgeContains(_ food: String) -&gt; Bool &#123; fridgeIsOpen = true defer &#123; fridgeIsOpen = false &#125; let result = fridgeContent.contains(food) return result&#125;fridgeContains(\"banana\")print(fridgeIsOpen) // false 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]},{"title":"swift 语言概要 - 6. 协议和扩展","slug":"swift06","date":"2019-04-27T01:13:01.000Z","updated":"2019-04-27T01:13:01.000Z","comments":true,"path":"20190427/swift06/","link":"","permalink":"https://www.zhangguangqun.com/20190427/swift06/","excerpt":"","text":"协议和扩展使用 protocal 来声明一个协议1234protocol ExampleProtocol &#123; var simpleDescription: String &#123; get &#125; mutating func adjust()&#125; 类，枚举，结构体都能采用协议 protocol采用协议后，需要有和协议一样的属性和方法。 1234567891011121314151617181920class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = \"A very simple class.\" var anotherProperty: Int = 69105 func adjust() &#123; simpleDescription += \" Now 100% adjusted.\" &#125;&#125;var a = SimpleClass()a.adjust()print(a.simpleDescription) // A very simple class. Now 100% adjusted.struct SimpleStructure: ExampleProtocol &#123; var simpleDescription: String = \"A simple structure\" mutating func adjust() &#123; simpleDescription += \" (adjusted)\" &#125;&#125;var b = SimpleStructure()b.adjust()print(b.simpleDescription) // A simple structure (adjusted) 使用 extension 来向一个已经存在的类型添加功能，例如一个新的方法，一个计算属性。您可以使用扩展来将协议一致性添加到在其他地方声明的类型，甚至添加到从库或框架导入的类型。123456789extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return \"The number \\(self)\" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) // The number 7 您可以像使用任何其他命名类型一样使用协议名称 - 例如，创建具有不同类型但都符合单个协议的对象集合。 使用类型为协议类型的值时，协议定义之外的方法不可用。123let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)// print(protocolValue.anotherProperty) // Value of type 'ExampleProtocol' has no member 'anotherProperty' 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]},{"title":"swift 语言概要 - 5. 枚举和结构体","slug":"swift05","date":"2019-04-24T14:23:10.000Z","updated":"2019-04-24T14:23:10.000Z","comments":true,"path":"20190424/swift05/","link":"","permalink":"https://www.zhangguangqun.com/20190424/swift05/","excerpt":"","text":"枚举和结构体使用 enum 来创建一个枚举，像创建类和其他命名的类型一样，枚举可以有方法。枚举的 rawValue 从 0 开始记数，依次加 1，如果某个 case 赋了特殊的值，那么从这个之后的再在一个的基础上进行加 1 记数。 1234567891011121314151617181920212223242526272829enum Rank: Int &#123; case ace = 1 case two, three, four, five, six, seven, eight, nine, ten case jack, queen, king case test = 20 case test2 func simpleDescription() -&gt; String &#123; switch self &#123; case .ace: return \"ace\" case .jack: return \"jack\" case .queen: return \"queen\" case .king: return \"king\" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValueprint(aceRawValue) // 1print(Rank.jack.rawValue) // 11print(Rank.test.rawValue) // 20print(Rank.test2.rawValue) // 21 枚举的类型可以是 String 和浮点型12345678910111213141516enum Sports: String &#123; case football, basketball case running = \"run\"&#125;print(Sports.football.rawValue) // footballprint(Sports.running.rawValue) // runenum Eyesight: Float &#123; case a case b case c = 5.2&#125;print(Eyesight.a.rawValue) // 0.0print(Eyesight.c.rawValue) // 5.2 可以使用 rawValue 来初始化一个枚举1234if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription() print(threeDescription)&#125; 枚举的 case 值就是实际的值，而不仅仅写它们的 rawValue 一种方式，如果没有很有意义的值，可以不必写。12345678910111213141516171819202122232425262728enum Suit &#123; case spades, hearts, diamonds, clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .spades: return \"spades\" case .hearts: return \"hearts\" case .diamonds: return \"diamonds\" case .clubs: return \"clubs\" &#125; &#125; func color() -&gt; String &#123; switch self &#123; case .spades, .clubs: return \"black\" case .hearts, .diamonds: return \"diamonds\" &#125; &#125;&#125;let hearts = Suit.heartslet heartsDescription = hearts.simpleDescription()print(Suit.spades.color()) // black 上面枚举例子在它定义时就已经确定了，并且相同的 case 的原始值都相同。还有一种情况是，枚举关联的原始值可以在它实例化时才确定，并且原始值可以不同1234567891011121314enum ServerResponse &#123; case result(String, String) case failure(String)&#125;let success = ServerResponse.result(\"6:00 am\", \"8:09 pm\")let failure = ServerResponse.failure(\"Out of cheese.\")switch success &#123; case let.result(sunrise, sunset): print(\"Sunrise is at \\(sunrise) and sunset is at \\(sunset).\") // Sunrise is at 6:00 am and sunset is at 8:09 pm. case let .failure(message): print(\"Failure... \\(message)\")&#125; 使用 struct 关键字来创建一个结构体，结构体支持很多与类相同的行为，包括方法和初始化方法。其中最重要的不同是结构体是一直被拷贝在传值的时候，而类是被当作引用来传递的。123456789struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return \"The \\(rank.simpleDescription()) of \\(suit.simpleDescription())\" &#125;&#125;let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]},{"title":"swift 语言概要 - 4. 对象和类","slug":"swift04","date":"2019-04-21T12:53:23.000Z","updated":"2019-04-21T12:53:23.000Z","comments":true,"path":"20190421/swift04/","link":"","permalink":"https://www.zhangguangqun.com/20190421/swift04/","excerpt":"","text":"对象和类在 class 关键字后面跟随一个类的名字来创建一个类。给类声明一个属性和普通的声明一个常量和变量的写法是一样的，只不过在类中声明的属性属于类的上下文。同样的，声明一个方法和函数是同样的写法。12345678910111213class Person &#123; var name = \"zhangguangqun\" let greetWord = \"hello\"// 类中声明的属性的需要初始化，否则编译出错// var age: Int // stored property 'age' without initial value prevents synthesized initializers func selfIntroduction() -&gt; String &#123; return \"\\(greetWord), my name is \\(name).\" &#125; func greet(name: String) -&gt; String &#123; return \"\\(greetWord), \\(name)\" &#125;&#125; 创建类的实例，及使用实例来访问实例的属性和方法。123var p = Person()print(p.selfIntroduction()) // hello, my name is zhangguangqun.print(p.greet(name: \"jack\")) // hello, jack 类的初始化，使用 init 初始化 (注意 init 方法前没有 func 关键字，也不会有返回值)，init 方法可以重载。1234567891011121314151617181920212223class Fruits &#123; var color: String var weight: Float = 0 init(color: String) &#123; self.color = color &#125; init(color: String, weight: Float) &#123;// 使用 self 表示该实例，来区分实例属性和方法传进来的参数。 self.color = color self.weight = weight &#125; func description() &#123; print(\"the color of this fruit is \\(color), it weight \\(weight)g\") &#125;&#125;var apple = Fruits(color: \"红色\")var banana = Fruits(color: \"黄色\", weight: 80)apple.description() // the color of this fruit is 红色, it weight 0.0gbanana.description() // the color of this fruit is 黄色, it weight 80.0g 类的继承，子类覆盖父类的方法必须要在方法前写上 override 关键字。对于子类没有自己的 init 初始化方法时，需要使用父类的 init 方法来初始化。对于子类有自己的 init 初始化方法时，它必须调用 super.init 。 12345678910111213141516171819202122232425262728class Apple: Fruits &#123; var price: Double// init(color: String, price: Double) &#123;// self.color = color// self.price = price// &#125;// 上面 init 这样的写法会产生如下错误：// 1. error: 'super.init' isn't called on all paths before returning from initializer// 2. error: 'self' used in property access 'color' before 'super.init' call self.color = color// 从这两个错误信息可以看出，在子类的构造器中，父类的成员变量必须通过父类的designated initializer进行初始化。也就是说，我们必须调用super.init（第一个error），而且在调用super.init之前不能使用和访问任何父类的成员变量（第二个error）。 init(color: String, price: Double) &#123; self.price = price super.init(color: color) &#125; override func description() &#123; print(\"这是苹果\") &#125;&#125;var appleFruit = Apple(color: \"红色\", price: 80)appleFruit.description()// 子类有自己的 init 方法，那么它只能调用自己 init 方法来初始化实例，不能调用父类的 init 方法。// var appleFruit1 = Apple(color: \"红色\", weight: 80) // error: incorrect argument label in call (have 'color:weight:', expected 'color:price:') 除了存储简单的属性之外，属性还可以有 getter 和 setter.1234567891011121314151617class Banana: Fruits &#123; var price: Double = 10 var weightKg: Double &#123; get &#123; return Double(weight / 1000); &#125; set &#123; weight = Float(newValue * 1000) &#125; &#125;&#125;var banana2 = Banana(color: \"黄色\", weight: 1000)print(banana2.weightKg) // 1.0banana2.weightKg = 0.5print(banana2.weight) // 500.0 如果你不需要计算属性，但是任然需要在设置新的值后做些操作，使用 willSet 和 didSet 。123456789101112131415161718192021222324252627class FruitBasket &#123; var apple: Apple &#123; willSet &#123; // 确保当 apple 属性被赋予新值时，banana 的 price 比 apple 的 price 低 2 banana.price = newValue.price - 2 &#125; &#125; var banana: Banana &#123; willSet &#123; // 确保当 banana 属性被赋予新值时，apple 的 price 比 banana 的 price 高 2 apple.price = newValue.price + 2 &#125; &#125; init(price: Double) &#123; apple = Apple(color: \"红色\", price: price) banana = Banana(color: \"黄色\") banana.price = apple.price - 2 &#125;&#125;var fruitBasket = FruitBasket(price: 10)print(fruitBasket.apple.price) // 10.0print(fruitBasket.banana.price) // 8.0fruitBasket.apple = Apple(color: \"红色\", price: 12)print(fruitBasket.apple.price) // 12.0print(fruitBasket.banana.price) // 10.0 对于一个可选值的类的实例，可以在方法、属性、下标前写上 (?) 来访问。如果这个实例是 nil，那么在 ? 之后的会被忽略，这个表达式的值是 nil。如果可选值不为 nil，那么可选值会被展开。对于这两种情况，整个表达式的值都是一个可选值。12var a: Apple? = Apple(color: \"红色\", price: 10)var price = a?.price 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]},{"title":"swift 语言概要 - 3. 函数和闭包","slug":"swift03","date":"2019-04-18T13:36:02.000Z","updated":"2019-04-18T13:36:02.000Z","comments":true,"path":"20190418/swift03/","link":"","permalink":"https://www.zhangguangqun.com/20190418/swift03/","excerpt":"","text":"函数和闭包1. 使用 func 来声明函数。调用函数时，传参和函数声明时的参数列表变量的名字保持一致。使用 -&gt; 在返回参数前且在函数参数列表后。1234func sayHello(name: String, day: String) -&gt; String &#123; return \"hello, \\(name), today is \\(day)\"&#125;print(sayHello(name: \"zhangsan\", day: \"星期三\")) // hello, zhangsan, today is 星期三 2. 函数使用参数的名字作为标签，调用该函数时根据这个标签来传参数。另外，可以在参数的名字前写一个自定义的标签，或者写下划线 _ 来表示不使用标签。1234func greet(userName name: String, _ day: String) -&gt; String &#123; return \"hello, \\(name), today is \\(day)\"&#125;print(greet(userName: \"zhangsan\", \"星期四\")) // hello, zhangsan, today is 星期四 3. 使用一个元祖来构成一个混合的值。例如，一个函数返回多个值，一个元祖的元素能够通过名字或者编号来引用。1234567891011121314151617func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])print(statistics.sum) // 120print(statistics.2) // 120 4. 函数能够嵌套，嵌套函数有外层函数声明的变量的访问权限。你能使用嵌套函数来组织在函数里很长或者很复杂的代码。123456789func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125;returnFifteen() 5. 函数是 first-class 类型的，这意味着一个函数能够返回另外一个函数作为它的返回值。12345678func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment = makeIncrementer()increment(7) // 8 6. 一个函数可以用另外一个函数作为他的参数。12345678910111213func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20, 19, 7, 12]hasAnyMatches(list: numbers, condition: lessThanTen) // true 7. 闭包，看官网的例子细细体会😄1234567891011121314var result = numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number return result&#125;)// 数组的每个值乘以3print(result) // [60, 57, 21, 36]// 简写版let mappedNumbers = numbers.map(&#123; number in 3 * number &#125;)print(mappedNumbers)// 更多例子let sortedNumbers = numbers.sorted &#123; $0 &gt; $1 &#125;print(sortedNumbers) 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]},{"title":"swift 语言概要 - 2. 流程控制","slug":"swift02","date":"2019-04-16T13:37:22.000Z","updated":"2019-04-16T13:37:22.000Z","comments":true,"path":"20190416/swift02/","link":"","permalink":"https://www.zhangguangqun.com/20190416/swift02/","excerpt":"","text":"流程控制用 if 和 switch 来做条件控制，用 for-in, while, 和 repeat-while 来做循环。12345678910111213let individualScores = [75, 86, 62, 50]var teamScores = 0for score in individualScores &#123;// if score &#123; // if 后的条件需要是 Bool 的值或者表达式 if score &gt;= 80 &#123; teamScores += 2 &#125; else if score &gt;= 60 &amp;&amp; score &lt; 80 &#123; teamScores += 1 &#125; else &#123; teamScores -= 1 &#125;&#125;print(teamScores) 可以将 if 和 let 组合使用，来处理变量值可能缺失的情况(值为 nil)。在变量的类型后加上 (?) 来表示该变量值是可选的1234567var optionalString: String?print(optionalString)var optionalName: String? = \"zhang\"if let name = optionalName &#123; print(\"hello \\(name)\") // hello zhang&#125; 另一种处理可选值的变量的情况是使用 (??) 操作符，如果可选值缺失了，那么就会使用默认值。1234let nickName: String? = nillet defaultName = \"Zhang San\"let name = nickName ?? defaultNameprint(name) Switches 支持任何类型的数据和多样的比较的类型。每个 case 后面不需要加 break, 执行一个分支后不会继续往后执行。1234567891011let fruits = \"香蕉\"switch fruits &#123;case \"苹果\": print(\"是苹果\")case \"橘子\", \"香蕉\": print(\"橘子和香蕉中的一种\")case let x where x.hasSuffix(\"子\"): print(\"水果名是以子结尾\")default: print(\"猜不出来是什么\")&#125; swift 中的 while 和其他语言一样。repeat-while 和其他语言的 do-while 一样。1234567891011var n = 2while n &lt; 100 &#123; n *= 2&#125;print(n)var m = 2repeat &#123; m *= 2&#125; while m &lt; 100print(m) 数组和字典的 for-in123456789101112131415let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest)// Prints \"25\" 使用 ..&lt; 来遍历一个范围的索引，..&lt; 不包括上界值。使用 … 可以包含两边的值12345var total = 0for i in 1..&lt;4 &#123; total += i&#125;print(total) 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]},{"title":"swift 语言概要 - 1. 简单值","slug":"swift01","date":"2019-04-13T13:34:43.000Z","updated":"2019-04-13T13:34:43.000Z","comments":true,"path":"20190413/swift01/","link":"","permalink":"https://www.zhangguangqun.com/20190413/swift01/","excerpt":"","text":"前言开始学习移动端的知识，从 ios 的 swift 语言开始。 swift 的 hello world:1print(\"hello world\") 1. 简单值1.1 用 var 来定义变量，用 let 来定义常量，常量值不能变123var a = 10a = 20let b = 20 1.2 声明变量时可以不显示地写出变量值的类型，让编译器根据变量值推断变量的类型。如果变量值没有足够的信息来推断出变量的类型，可以显示声明变量的类型123let valueInterger = 10let valueDouble = 10.0let explicitDouble: Double = 10 1.3 值的类型不会隐示的转换，只能显示的进行转换123let label = \"This width is \"let width = 1let widthLabel = label + String(width) 1.4 一种简单的方式将值嵌入到字符串里1234let apples = 3let oranges = 5let appleSummary = \"I have \\(apples) apples.\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 1.5 多行的字符串用 “””12345678let quotation = \"\"\"Even though there's whitespace to the left,the actual lines aren't indented.Except for this line.Double quotes (\") can appear without being escaped.\\\"I still have \\(apples + oranges) pieces of fruit.\"\"\" 1.6 数组和字典数组的类型需要一致，字典的值也需要一致123456var arr = [1, 2, 3]arr.append(4)arr[0] = 2var dict = [\"k1\": \"v1\", \"k2\": \"v2\"]dict[\"k3\"] = \"k3\"print(dict) 1.7 定义空的数组和空的字典12var emptyArray = [String]()var emptyDictionary = [String: String]() 如果数组和字典的值能够被推断，那么可以用 [] 和 [:] 来表示。比如给一个变量赋新值或者给一个方法传参。12arr = []dict = [:] 查看源码 参考：1. 苹果官网 swift 指南","categories":[{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/categories/ios/"},{"name":"swift","slug":"ios/swift","permalink":"https://www.zhangguangqun.com/categories/ios/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://www.zhangguangqun.com/tags/swift/"},{"name":"ios","slug":"ios","permalink":"https://www.zhangguangqun.com/tags/ios/"}]}]}